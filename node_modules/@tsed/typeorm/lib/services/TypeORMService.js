"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeORMService = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const typeorm_1 = require("typeorm");
const createConnection_1 = require("../utils/createConnection");
let TypeORMService = class TypeORMService {
    constructor() {
        /**
         *
         * @type {"typeorm".ConnectionManager}
         * @private
         */
        this.connectionManager = typeorm_1.getConnectionManager();
    }
    /**
     *
     * @type {Map<any, any>}
     * @deprecated
     */
    // istanbul ignore next
    get instances() {
        return this.connectionManager;
    }
    /**
     *
     * @returns {Promise<"typeorm".Connection>}
     */
    async createConnection(id = "default", settings) {
        const key = settings.name || id;
        if (key && this.has(key)) {
            return this.get(key);
        }
        this.injector.logger.info(`Create connection with typeorm to database: ${key}`);
        this.injector.logger.debug(`options: ${JSON.stringify(settings)}`);
        try {
            const connection = await createConnection_1.createConnection({ ...settings, name: key });
            this.injector.logger.info(`Connected with typeorm to database: ${key}`);
            return connection;
        }
        catch (err) {
            /* istanbul ignore next */
            console.error(err);
            /* istanbul ignore next */
            process.exit();
        }
    }
    /**
     *
     * @returns {"typeorm".Connection}
     */
    get(id = "default") {
        return this.connectionManager.get(id);
    }
    /**
     *
     * @param {string} id
     * @returns {boolean}
     */
    has(id = "default") {
        return this.connectionManager.has(id);
    }
    closeConnections() {
        const promises = this.connectionManager.connections.map((instance) => {
            if (instance.isConnected) {
                return instance.close();
            }
        });
        return Promise.all(promises);
    }
};
tslib_1.__decorate([
    common_1.Inject(common_1.InjectorService),
    tslib_1.__metadata("design:type", common_1.InjectorService)
], TypeORMService.prototype, "injector", void 0);
TypeORMService = tslib_1.__decorate([
    common_1.Service()
], TypeORMService);
exports.TypeORMService = TypeORMService;
//# sourceMappingURL=TypeORMService.js.map