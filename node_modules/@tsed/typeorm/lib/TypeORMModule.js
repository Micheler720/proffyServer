"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeORMModule = void 0;
const common_1 = require("@tsed/common");
const typeorm_1 = require("typeorm");
const TypeORMService_1 = require("./services/TypeORMService");
class TypeORMModule {
    constructor(configuration, typeORMService) {
        this.typeORMService = typeORMService;
        this.settings = configuration.get("typeorm") || {};
    }
    async init() {
        const promises = Object.keys(this.settings).map((key) => this.typeORMService.createConnection(key, this.settings[key]));
        return Promise.all(promises);
    }
    $onDestroy() {
        return this.typeORMService.closeConnections();
    }
}
exports.TypeORMModule = TypeORMModule;
common_1.registerProvider({
    provide: TypeORMModule,
    deps: [common_1.Configuration, TypeORMService_1.TypeORMService, common_1.InjectorService],
    resolvers: [
        {
            deps: [TypeORMModule],
            get(type, options) {
                try {
                    return typeorm_1.getCustomRepository(type, options.connection || "default");
                }
                catch (er) { }
            }
        }
    ],
    injectable: false,
    async useAsyncFactory(configuration, typeORMService, injector) {
        typeorm_1.useContainer({
            get(type) {
                return injector.hasProvider(type) ? injector.get(type) : undefined;
            }
        }, { fallback: true });
        const typeORMModule = new TypeORMModule(configuration, typeORMService);
        await typeORMModule.init();
        return typeORMModule;
    }
});
//# sourceMappingURL=TypeORMModule.js.map